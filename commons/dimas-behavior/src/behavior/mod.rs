// Copyright Â© 2025 Stephan Kunz

//! [`Behavior`] library
//!

// #[allow(clippy::module_inception)]
pub mod action;
#[allow(clippy::module_inception)]
mod behavior;
pub mod condition;
pub mod control;
pub mod decorator;
pub mod error;
mod simple_behavior;

// flatten
pub use behavior::{BehaviorConfigurationData, BehaviorTickData};
pub use simple_behavior::{ComplexBhvrTickFn, SimpleBehavior, SimpleBhvrTickFn};

// region:      --- modules
use alloc::boxed::Box;
use error::BehaviorError;

use crate::{port::PortList, tree::{BehaviorTreeComponent, BehaviorTreeComponentList}};
// endregion:   --- modules

// region:		--- types
/// Pointer to a  [`Behavior`]
pub type BehaviorPtr = Box<dyn BehaviorTreeMethods>;

/// Result type definition for [`Behavior`]s
pub type BehaviorResult<Output = BehaviorStatus> = Result<Output, BehaviorError>;

/// Type alias for a [`Behavior`] creation function
pub type BehaviorCreationFn = dyn Fn() -> BehaviorPtr + Send + Sync;
// endregion:	--- types

// region:      --- supertraits
/// Supertrait for a [`Behavior`]
pub trait BehaviorAllMethods:
	BehaviorTreeMethods + BehaviorStaticMethods + BehaviorCreationMethods
{
}

/// Supertrait for execution of a [`Behavior`]
pub trait BehaviorTreeMethods: BehaviorInstanceMethods + BehaviorRedirectionMethods {}
// endregion:   --- supertraits

// region:      --- BehaviorCreationMethods
/// Methods needed for [`Behavior`] creation
pub trait BehaviorCreationMethods: Default {
	/// Provide the boxed creation function
	#[must_use]
	fn creation_fn() -> Box<BehaviorCreationFn>;
}
// endregion:   --- BehaviorCreationMethods

// region:		--- BehaviorInstanceMethods
/// Defines the methods common to all [`Behavior`]s.
/// These methods are available when traversing a [`BehaviorTree`].
pub trait BehaviorInstanceMethods: core::fmt::Debug + Send + Sync {
	/// Method called to stop/cancel/halt a [`Behavior`].
	/// Default implementation just returns [`BehaviorStatus::Idle`]
	/// # Errors
	#[allow(unused_variables)]
	fn halt(&mut self, children: &mut BehaviorTreeComponentList) -> Result<(), BehaviorError> {
		for child in &mut **children {
			child.halt(0)?;
		}
		Ok(())
	}

	/// Method called to start ticking a [`Behavior`].
	/// Defaults to calling `self.tick(...)`
	/// # Errors
	fn start(
		&mut self,
		tick_data: &mut BehaviorTickData,
		children: &mut BehaviorTreeComponentList,
	) -> BehaviorResult {
		self.tick(tick_data, children)
	}

	/// Method called to tick a [`Behavior`].
	/// # Errors
	fn tick(
		&mut self,
		tick_data: &mut BehaviorTickData,
		children: &mut BehaviorTreeComponentList,
	) -> BehaviorResult;
}
// endregion:	--- BehaviorInstanceMethods

// region:      --- BehaviorRedirectionMethods
/// Redirections to static methods of [`Behavior`]s
/// These methods are generated by the derive macro.
pub trait BehaviorRedirectionMethods: core::fmt::Debug + Send + Sync {
	/// Get the `static` list of defined [`Port`]s.
	#[must_use]
	fn static_provided_ports(&self) -> PortList;
}
// endregion:   --- BehaviorRedirectionMethods

// region:      --- BehaviorStaticMethods
/// Static methods of [`Behavior`]s
pub trait BehaviorStaticMethods: Default {
	// This does not work, because self does not know its correct type
	// fn create() -> Box<BehaviorCreationFn> {
	// 	Box::new(|| Box::new(Self::default()))
	// }

	/// Get the kind of the [`Behavior`] that shall become a Node in a [`BehaviorSubTree`]
	#[must_use]
	fn kind() -> BehaviorType;

	/// Provide the list of defined [`Port`]s.
	/// Default implementation returns an empty list.
	#[must_use]
	fn provided_ports() -> PortList {
		PortList::default()
	}
}
// endregion:   --- BehaviorStaticMethods

// region:      --- BehaviorStatus
/// Behavior status
#[allow(clippy::module_name_repetitions)]
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
pub enum BehaviorStatus {
	/// Behavior execution failed.
	Failure,
	/// Behavior is not executing.
	#[default]
	Idle,
	/// Behavior is still executing.
	Running,
	/// Behavior has been skipped.
	Skipped,
	/// Behavior finished with success.
	Success,
}

impl BehaviorStatus {
	/// Check if status is signaling that the behavior is active
	#[must_use]
	pub const fn is_active(&self) -> bool {
		matches!(self, Self::Idle | Self::Skipped)
	}

	/// Check if status is signaling that the behavior is completed
	#[must_use]
	pub const fn is_completed(&self) -> bool {
		matches!(self, Self::Success | Self::Failure)
	}
}

impl core::fmt::Display for BehaviorStatus {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let text = match self {
			Self::Failure => "Failure",
			Self::Idle => "Idle",
			Self::Running => "Running",
			Self::Skipped => "Skipped",
			Self::Success => "Success",
		};

		write!(f, "{text}")
	}
}
// endregion:   --- BehaviorStatus

// region:		--- BehaviorType
/// All types of behaviors usable in a behavior tree.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum BehaviorType {
	/// Action
	Action,
	/// Condition
	Condition,
	/// Control
	Control,
	/// Decorator
	Decorator,
	/// Subtree
	SubTree,
}

impl core::fmt::Display for BehaviorType {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let text = match self {
			Self::Action => "Action",
			Self::Condition => "Condition",
			Self::Control => "Control",
			Self::Decorator => "Decorator",
			Self::SubTree => "SubTree",
		};

		write!(f, "{text}")
	}
}
// endregion:	--- BehaviorType
