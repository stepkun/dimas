// Copyright Â© 2025 Stephan Kunz

//! The Behavior part of the library
//!

pub mod action;
#[allow(clippy::module_inception)]
pub mod condition;
pub mod control;
pub mod decorator;
pub mod error;
pub mod pre_post_conditions;
mod simple_behavior;

use dimas_core::ConstString;
// flatten
pub use error::BehaviorError;
pub use simple_behavior::{ComplexBhvrTickFn, SimpleBehavior, SimpleBhvrTickFn};

// region:      --- modules
use alloc::{boxed::Box, vec::Vec};
use core::any::Any;
use dimas_scripting::SharedRuntime;

use crate::{blackboard::SharedBlackboard, port::PortList, tree::BehaviorTreeElementList};
// endregion:   --- modules

// region:		--- types
/// Pointer to a behavior.
pub type BehaviorPtr = Box<dyn BehaviorExecution>;

/// Result type definition for behaviors.
pub type BehaviorResult<Output = BehaviorState> = Result<Output, BehaviorError>;

/// Type alias for a behavior creation function
pub type BehaviorCreationFn = dyn Fn() -> BehaviorPtr + Send + Sync;

/// [`BehaviorData`] state change callback signature.
///
/// This callback can be used to observe [`BehaviorData`] and manipulate the resulting [`BehaviorState`] of a tick.
pub type BehaviorTickCallback = dyn Fn(&BehaviorData, &mut BehaviorState) + Send + Sync + 'static;
// endregion:   --- types

// region:      --- supertraits
/// Supertrait for a behavior.
pub trait Behavior: BehaviorExecution + BehaviorStatic + BehaviorCreation {}

/// Supertrait for execution of a behavior.
pub trait BehaviorExecution: Any + BehaviorInstance + BehaviorRedirection {
	/// Needed for dynamic downcasting
	fn as_any(&self) -> &dyn Any;
	/// Needed for mutable dynamic downcasting
	fn as_any_mut(&mut self) -> &mut dyn Any;
}
// endregion:   --- supertraits

// region:      --- BehaviorCreation
/// Methods needed for behavior creation.
pub trait BehaviorCreation: Default {
	/// Provide the boxed creation function.
	#[must_use]
	fn creation_fn() -> Box<BehaviorCreationFn>;
}
// endregion:   --- BehaviorCreation

// region:		--- BehaviorInstance
/// Defines the methods common to all behaviors.
/// These methods are available when traversing a behavior tree.
#[async_trait::async_trait]
pub trait BehaviorInstance: core::fmt::Debug + Send + Sync {
	/// Method called to stop/cancel/halt a behavior.
	/// Default implementation halts all children and sets state to idle.
	/// # Errors
	async fn halt(
		&mut self,
		behavior: &mut BehaviorData,
		children: &mut BehaviorTreeElementList,
		runtime: &SharedRuntime,
	) -> Result<(), BehaviorError> {
		for child in &mut **children {
			child.halt(0, runtime)?;
		}

		behavior.set_state(BehaviorState::Idle);
		Ok(())
	}

	/// Method called to start ticking a behavior.
	/// Defaults to calling `self.tick(...)`
	/// # Errors
	async fn start(
		&mut self,
		behavior: &mut BehaviorData,
		blackboard: &mut SharedBlackboard,
		children: &mut BehaviorTreeElementList,
		runtime: &SharedRuntime,
	) -> BehaviorResult {
		self.tick(behavior, blackboard, children, runtime)
			.await
	}

	/// Method called to tick a behavior.
	/// # Errors
	async fn tick(
		&mut self,
		behavior: &mut BehaviorData,
		blackboard: &mut SharedBlackboard,
		children: &mut BehaviorTreeElementList,
		runtime: &SharedRuntime,
	) -> BehaviorResult;
}
// endregion:	--- BehaviorInstance

// region:      --- BehaviorRedirection
/// Redirections to static methods of behaviors.
/// These methods are generated by the derive macro.
pub trait BehaviorRedirection: core::fmt::Debug + Send + Sync {
	/// Get the `static` list of defined ports.
	#[must_use]
	fn static_provided_ports(&self) -> PortList;
}
// endregion:   --- BehaviorRedirection

// region:      --- BehaviorStatic
/// Static methods of behaviors.
pub trait BehaviorStatic: Default {
	/// Get the [`BehaviorType`] of the behavior that shall become a node in a behavior (sub)tree.
	#[must_use]
	fn kind() -> BehaviorKind;

	/// Provide the list of defined ports.
	/// Default implementation returns an empty list.
	#[must_use]
	fn provided_ports() -> PortList {
		PortList::default()
	}
}
// endregion:   --- BehaviorStatic

// region:      --- BehaviorData
/// Structure for implementing behaviors.
#[derive(Default)]
pub struct BehaviorData {
	/// UID of the behavior within the [`BehaviorTree`](crate::tree::BehaviorTree).
	/// 65536 behaviors in a [`BehaviorTree`](crate::tree::BehaviorTree) should be sufficient.
	/// The ordering of the uid is following the creation order by the [`XmlParser`](crate::factory::xml_parser::XmlParser).
	/// This should end up in a depth first ordering.
	pub(crate) uid: u16,
	/// Name of the element.
	pub(crate) name: ConstString,
	/// Path to the element.
	/// In contrast to BehaviorTree.CPP this path is fully qualified,
	/// which means that every level is denoted explicitly, including the tree root.
	pub(crate) path: ConstString,
	/// Current state of the behavior.
	state: BehaviorState,
	/// List of pre state change callbacks with an identifier.
	/// These callbacks can be used for observation of the [`BehaviorTreeElement`] and
	/// for manipulation of the resulting [`BehaviorState`] of a tick.
	pre_state_change_hooks: Vec<(ConstString, Box<BehaviorTickCallback>)>,
}

impl BehaviorData {
	/// Constructor
	#[must_use]
	pub fn new(uid: u16, name: &str, path: &str) -> Self {
		Self {
			uid,
			name: name.into(),
			path: path.into(),
			state: BehaviorState::default(),
			pre_state_change_hooks: Vec::default(),
		}
	}
	/// Method to get the name.
	#[must_use]
	pub fn name(&self) -> &str {
		&self.name
	}

	/// Method to get the uid.
	#[must_use]
	pub const fn uid(&self) -> u16 {
		self.uid
	}

	/// Method to get the state.
	#[must_use]
	pub const fn state(&self) -> BehaviorState {
		self.state
	}

	/// Method to set the state.
	pub fn set_state(&mut self, state: BehaviorState) {
		// Callback before setting state
		let mut state = state;
		for (_, callback) in &self.pre_state_change_hooks {
			callback(self, &mut state);
		}
		self.state = state;
	}

	/// Add a pre state change callback with the given name.
	/// The name is not unique, which is important when removing callback.
	pub fn add_pre_state_change_callback<T>(&mut self, name: ConstString, callback: T)
	where
		T: Fn(&Self, &mut BehaviorState) + Send + Sync + 'static,
	{
		self.pre_state_change_hooks
			.push((name, Box::new(callback)));
	}

	/// Remove any pre state change callback with the given name.
	pub fn remove_pre_state_change_callback(&mut self, name: &ConstString) {
		// first collect all subscriber with that name ...
		let mut indices = Vec::new();
		for (index, (cb_name, _)) in self.pre_state_change_hooks.iter().enumerate() {
			if cb_name == name {
				indices.push(index);
			}
		}
		// ... then remove them from vec
		for index in indices {
			let _ = self.pre_state_change_hooks.remove(index);
		}
	}
}
// endregion:	--- BehaviorData

// region:		--- BehaviorDescription
/// Description of a Behavior, used in xml parsing and creating.
#[derive(Clone, Debug)]
pub struct BehaviorDescription {
	/// Name of the behavior.
	name: ConstString,
	/// Kind of the behavior.
	kind: BehaviorKind,
	/// Flag to indicate whether this behavior is builtin by Groot2.
	groot2: bool,
	/// The [`PortList`]
	ports: PortList,
}

impl BehaviorDescription {
	/// Create a behavior description.
	#[must_use]
	pub fn new(name: &str, kind: BehaviorKind, groot2: bool, ports: PortList) -> Self {
		Self {
			name: name.into(),
			kind,
			groot2,
			ports,
		}
	}

	/// Get name
	#[must_use]
	pub fn name(&self) -> ConstString {
		self.name.clone()
	}

	/// Get kind
	#[must_use]
	pub const fn kind(&self) -> BehaviorKind {
		self.kind
	}

	/// Get kind as str
	#[must_use]
	pub const fn kind_str(&self) -> &'static str {
		self.kind.as_str()
	}

	/// If is builtin of Groot2
	#[must_use]
	pub const fn groot2(&self) -> bool {
		self.groot2
	}

	/// Get ports
	#[must_use]
	pub const fn ports(&self) -> &PortList {
		&self.ports
	}
}
// endregion:	--- BehaviorDescription

// region:		--- BehaviorKind
static ACTION: &str = "Action";
static CONDITION: &str = "Condition";
static CONTROL: &str = "Control";
static DECORATOR: &str = "Decorator";
static SUBTREE: &str = "SubTree";

/// All types of behaviors usable in a behavior tree.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum BehaviorKind {
	/// Action
	Action,
	/// Condition
	Condition,
	/// Control
	Control,
	/// Decorator
	Decorator,
	/// Subtree
	SubTree,
}

impl core::fmt::Display for BehaviorKind {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		write!(f, "{}", self.as_str())
	}
}

impl BehaviorKind {
	/// Provide a static str reference
	#[must_use]
	pub const fn as_str(&self) -> &'static str {
		match self {
			Self::Action => ACTION,
			Self::Condition => CONDITION,
			Self::Control => CONTROL,
			Self::Decorator => DECORATOR,
			Self::SubTree => SUBTREE,
		}
	}
}
// endregion:	--- BehaviorKind

// region:      --- BehaviorState
/// Behavior state
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
pub enum BehaviorState {
	/// Behavior execution failed.
	Failure,
	/// Behavior is not executing.
	#[default]
	Idle,
	/// Behavior is still executing.
	Running,
	/// Behavior has been skipped.
	Skipped,
	/// Behavior finished with success.
	Success,
}

impl BehaviorState {
	/// Check if state is signaling that the behavior is active
	#[must_use]
	pub const fn is_active(&self) -> bool {
		matches!(self, Self::Idle | Self::Skipped)
	}

	/// Check if state is signaling that the behavior is completed
	#[must_use]
	pub const fn is_completed(&self) -> bool {
		matches!(self, Self::Success | Self::Failure)
	}
}

impl core::fmt::Display for BehaviorState {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let text = match self {
			Self::Failure => "Failure",
			Self::Idle => "Idle",
			Self::Running => "Running",
			Self::Skipped => "Skipped",
			Self::Success => "Success",
		};

		write!(f, "{text}")
	}
}

impl core::str::FromStr for BehaviorState {
	type Err = BehaviorError;

	fn from_str(s: &str) -> Result<Self, Self::Err> {
		let s = s.to_ascii_lowercase();
		let res = match s.as_ref() {
			"failure" => Self::Failure,
			"idle" => Self::Idle,
			"running" => Self::Running,
			"skipped" => Self::Skipped,
			"success" => Self::Success,
			_ => return Err(BehaviorError::ParseError(s.into(), "BehaviorState::from_str()".into())),
		};
		Ok(res)
	}
}
// endregion:   --- BehaviorState
