// Copyright Â© 2025 Stephan Kunz

//! The Behavior part of the library
//!

pub mod action;
#[allow(clippy::module_inception)]
mod behavior;
pub mod condition;
pub mod control;
pub mod decorator;
pub mod error;
mod simple_behavior;

// flatten
pub use behavior::{BehaviorConfigurationData, BehaviorTickData};
pub use simple_behavior::{ComplexBhvrTickFn, SimpleBehavior, SimpleBhvrTickFn};

// region:      --- modules
use alloc::boxed::Box;
use core::any::Any;
use error::BehaviorError;

use crate::{
	blackboard::SharedBlackboard,
	port::PortList,
	tree::{BehaviorTreeComponent, BehaviorTreeComponentList},
};
// endregion:   --- modules

// region:		--- types
/// Pointer to a behavior.
pub type BehaviorPtr = Box<dyn BehaviorExecution>;

/// Result type definition for behaviors.
pub type BehaviorResult<Output = BehaviorStatus> = Result<Output, BehaviorError>;

/// Type alias for a behavior creation function
pub type BehaviorCreationFn = dyn Fn() -> BehaviorPtr + Send + Sync;
// endregion:	--- types

// region:      --- supertraits
/// Supertrait for a behavior.
pub trait Behavior: BehaviorExecution + BehaviorStatic + BehaviorCreation {}

/// Supertrait for execution of a behavior.
pub trait BehaviorExecution: Any + BehaviorInstance + BehaviorRedirection {
	/// Needed for dynamic downcasting
	fn as_any(&self) -> &dyn Any;
	/// Needed for mutable dynamic downcasting
	fn as_any_mut(&mut self) -> &mut dyn Any;
}
// endregion:   --- supertraits

// region:      --- BehaviorCreation
/// Methods needed for behavior creation.
pub trait BehaviorCreation: Default {
	/// Provide the boxed creation function.
	#[must_use]
	fn creation_fn() -> Box<BehaviorCreationFn>;
}
// endregion:   --- BehaviorCreation

// region:		--- BehaviorInstance
/// Defines the methods common to all behaviors.
/// These methods are available when traversing a behavior tree.
pub trait BehaviorInstance: core::fmt::Debug + Send + Sync {
	/// Method called to stop/cancel/halt a behavior.
	/// Default implementation just returns [`BehaviorStatus::Idle`]
	/// # Errors
	fn halt(&mut self, children: &mut BehaviorTreeComponentList) -> Result<(), BehaviorError> {
		for child in &mut **children {
			child.halt(0)?;
		}
		Ok(())
	}

	/// Method called to start ticking a behavior.
	/// Defaults to calling `self.tick(...)`
	/// # Errors
	fn start(
		&mut self,
		tick_data: &mut BehaviorTickData,
		blackboard: &mut SharedBlackboard,
		children: &mut BehaviorTreeComponentList,
	) -> BehaviorResult {
		self.tick(tick_data, blackboard, children)
	}

	/// Method called to tick a behavior.
	/// # Errors
	fn tick(
		&mut self,
		tick_data: &mut BehaviorTickData,
		blackboard: &mut SharedBlackboard,
		children: &mut BehaviorTreeComponentList,
	) -> BehaviorResult;
}
// endregion:	--- BehaviorInstance

// region:      --- BehaviorRedirection
/// Redirections to static methods of behaviors.
/// These methods are generated by the derive macro.
pub trait BehaviorRedirection: core::fmt::Debug + Send + Sync {
	/// Get the `static` list of defined ports.
	#[must_use]
	fn static_provided_ports(&self) -> PortList;
}
// endregion:   --- BehaviorRedirection

// region:      --- BehaviorStatic
/// Static methods of behaviors.
pub trait BehaviorStatic: Default {
	/// Get the [`BehaviorType`] of the behavior that shall become a node in a behavior (sub)tree.
	#[must_use]
	fn kind() -> BehaviorType;

	/// Provide the list of defined ports.
	/// Default implementation returns an empty list.
	#[must_use]
	fn provided_ports() -> PortList {
		PortList::default()
	}
}
// endregion:   --- BehaviorStatic

// region:      --- BehaviorStatus
/// Behavior status
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
pub enum BehaviorStatus {
	/// Behavior execution failed.
	Failure,
	/// Behavior is not executing.
	#[default]
	Idle,
	/// Behavior is still executing.
	Running,
	/// Behavior has been skipped.
	Skipped,
	/// Behavior finished with success.
	Success,
}

impl BehaviorStatus {
	/// Check if status is signaling that the behavior is active
	#[must_use]
	pub const fn is_active(&self) -> bool {
		matches!(self, Self::Idle | Self::Skipped)
	}

	/// Check if status is signaling that the behavior is completed
	#[must_use]
	pub const fn is_completed(&self) -> bool {
		matches!(self, Self::Success | Self::Failure)
	}
}

impl core::fmt::Display for BehaviorStatus {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let text = match self {
			Self::Failure => "Failure",
			Self::Idle => "Idle",
			Self::Running => "Running",
			Self::Skipped => "Skipped",
			Self::Success => "Success",
		};

		write!(f, "{text}")
	}
}
// endregion:   --- BehaviorStatus

// region:		--- BehaviorType
/// All types of behaviors usable in a behavior tree.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum BehaviorType {
	/// Action
	Action,
	/// Condition
	Condition,
	/// Control
	Control,
	/// Decorator
	Decorator,
	/// Subtree
	SubTree,
}

impl core::fmt::Display for BehaviorType {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let text = match self {
			Self::Action => "Action",
			Self::Condition => "Condition",
			Self::Control => "Control",
			Self::Decorator => "Decorator",
			Self::SubTree => "SubTree",
		};

		write!(f, "{text}")
	}
}
// endregion:	--- BehaviorType

// region:		---macros
/// Macro to register a behavior with additional arguments.
/// 
/// # Usage:
/// `register_node!(<mutable reference to behavior factory>, <struct to register>, <"identifying name">, <arg1>, <arg2>, ...>)`
/// 
/// # Example
/// `register_node!(&mut factory, ActionA, "Action_A", 42, "hello world".into())?;`
#[macro_export]
macro_rules! register_node {
	($factory:expr, $tp:ident, $name:expr, $($arg:expr),* $(,)?) => {{
		let bhvr_creation_fn = Box::new(move || -> Box<dyn BehaviorExecution> {
		Box::new($tp::new($($arg),*))
	});
	$factory
		.registry()
		.add_behavior("Action_A", bhvr_creation_fn, ActionA::kind())
	}};
}
// endregion:	---macros
