// Copyright Â© 2025 Stephan Kunz

//! [`Behavior`] library
//!

// #[allow(clippy::module_inception)]
pub mod action;
mod behavior;
pub mod condition;
pub mod control;
pub mod decorator;
pub mod error;
mod simple_behavior;

// flatten
pub use behavior::{BehaviorConfigurationData, BehaviorTickData};
pub use simple_behavior::{ComplexBhvrTickFn, SimpleBehavior, SimpleBhvrTickFn};

// region:      --- modules
use alloc::boxed::Box;
use error::NewBehaviorError;

use crate::{new_port::NewPortList, tree::BehaviorTreeComponent};
// endregion:   --- modules

// region:		--- types
/// Result type definition for [`Behavior`]s
pub type BehaviorResult<Output = NewBehaviorStatus> = Result<Output, NewBehaviorError>;

/// Type alias for a [`Behavior`] creation function
pub type BehaviorCreationFn = dyn Fn() -> Box<dyn BehaviorTreeMethods> + Send + Sync;
// endregion:	--- types

// region:      --- supertraits
/// Supertrait for a [`Behavior`]
pub trait BehaviorAllMethods:
	BehaviorTreeMethods + BehaviorStaticMethods + BehaviorCreationMethods
{
}
/// Supertrait for execution of a [`Behavior`]
pub trait BehaviorTreeMethods: BehaviorInstanceMethods + BehaviorRedirectionMethods {}
// endregion:   --- supertraits

// region:      --- BehaviorCreationMethods
/// Methods needed for [`Behavior`] creation
pub trait BehaviorCreationMethods {
	/// Provide the boxed creation function
	#[must_use]
	fn create() -> Box<BehaviorCreationFn>;
	/// Get the kind of the [`Behavior`] that shall become a Node in a [`BehaviorSubTree`]
	#[must_use]
	fn kind() -> NewBehaviorType;
}
// endregion:   --- BehaviorCreationMethods

// region:		--- BehaviorInstanceMethods
/// Defines the methods common to all [`Behavior`]s.
/// These methods are available when traversing a [`BehaviorTree`].
pub trait BehaviorInstanceMethods: core::fmt::Debug + Send + Sync {
	/// Method called to start ticking a [`Behavior`].
	/// Defaults to calling `self.tick(...)`
	/// # Errors
	fn start(&mut self, tree_node: &mut BehaviorTreeComponent) -> BehaviorResult {
		self.tick(tree_node)
	}

	/// Method called to tick a [`Behavior`].
	/// # Errors
	fn tick(&mut self, tree_node: &mut BehaviorTreeComponent) -> BehaviorResult;

	/// Method called to stop/cancel/halt a [`Behavior`].
	/// Default implementation just returns [`BehaviorStatus::Idle`]
	/// # Errors
	#[allow(unused_variables)]
	fn halt(&mut self, tree_node: &mut BehaviorTreeComponent) -> BehaviorResult {
		Ok(NewBehaviorStatus::Idle)
	}
}
// endregion:	--- BehaviorInstanceMethods

// region:      --- BehaviorRedirectionMethods
/// Redirections to static methods of [`Behavior`]s
/// These methods are generated by the derive macro.
pub trait BehaviorRedirectionMethods: core::fmt::Debug + Send + Sync {
	/// Get the `static` list of defined [`Port`]s.
	#[must_use]
	fn static_provided_ports(&self) -> NewPortList;
}
// endregion:   --- BehaviorRedirectionMethods

// region:      --- BehaviorStaticMethods
/// Static methods of [`Behavior`]s
pub trait BehaviorStaticMethods {
	/// Provide the list of defined [`Port`]s.
	/// Default implementation returns an empty list.
	#[must_use]
	fn provided_ports() -> NewPortList {
		NewPortList::default()
	}
}
// endregion:   --- BehaviorStaticMethods

// region:      --- BehaviorStatus
/// Behavior status
#[allow(clippy::module_name_repetitions)]
#[derive(Clone, Copy, Debug, Default, PartialEq, Eq)]
#[repr(u8)]
pub enum NewBehaviorStatus {
	/// Behavior execution failed.
	Failure,
	/// Behavior is not executing.
	#[default]
	Idle,
	/// Behavior is still executing.
	Running,
	/// Behavior has been skipped.
	Skipped,
	/// Behavior finished with success.
	Success,
}

impl NewBehaviorStatus {
	/// Check if status is signaling that the behavior is active
	#[must_use]
	pub const fn is_active(&self) -> bool {
		matches!(self, Self::Idle | Self::Skipped)
	}

	/// Check if status is signaling that the behavior is completed
	#[must_use]
	pub const fn is_completed(&self) -> bool {
		matches!(self, Self::Success | Self::Failure)
	}
}

impl core::fmt::Display for NewBehaviorStatus {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let text = match self {
			Self::Failure => "Failure",
			Self::Idle => "Idle",
			Self::Running => "Running",
			Self::Skipped => "Skipped",
			Self::Success => "Success",
		};

		write!(f, "{text}")
	}
}
// endregion:   --- BehaviorStatus

// region:		--- BehaviorType
/// All types of behaviors usable in a behavior tree.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum NewBehaviorType {
	/// Action
	Action,
	/// Condition
	Condition,
	/// Control
	Control,
	/// Decorator
	Decorator,
	/// Subtree
	SubTree,
}

impl core::fmt::Display for NewBehaviorType {
	fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
		let text = match self {
			Self::Action => "Action",
			Self::Condition => "Condition",
			Self::Control => "Control",
			Self::Decorator => "Decorator",
			Self::SubTree => "SubTree",
		};

		write!(f, "{text}")
	}
}
// endregion:	--- BehaviorType
